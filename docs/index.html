<!DOCTYPE HTML>
<html>
<head>
  <title>AnimateForms v1.3.2a</title>
  <meta name="description" content="AnimateForms is a lightweight, asynchronous Windows Forms animation library. Use it to build your next WinForms project today.">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Nunito:200,400&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" type="text/css" href="lib/flexcore.min.css">
  <link rel="stylesheet" type="text/css" href="css/site.css">
</head>
<body>
  <header>
    <nav class="flex-row align-center">
      <img src="img/ico.svg" alt="Logo">
      <span class="nav-spacer"></span>
      <a href="https://github.com/SDBagel/AnimateForms">
        <button>GitHub</button>
      </a>
    </nav>
  </header>
  <div class="block-header">
    <img src="img/Code-Banner.png" alt="Banner with Code">
    <h1>AnimateForms</h1>
  </div>
  <div class="container-wide">
    <div class="flex-column align-center">
      <p><b>Documentation version: <code>v1.3.2-alpha</code></b></p>
      <p><b><a href="old/">Need older documentation?</a> | <a href="new/">What's next in v1.4.0a?</a></b></p>
    </div>
    <br>
    <section class="flex-smart flex-list">
      <div class="card flex">
        <h2>Preproduction Warning</h2>
        <p>While this library is mostly stable, I don't recommend the use of it in production. You have been warned.</p>
      </div>
      <div class="card flex">
        <h2>Examples & Demos</h2>
        <p>Example snippets are included in this documentation. <a href="https://github.com/SDBagel/AnimateForms/releases">A basic demo app is available on GitHub.</a></p>
      </div>
      <div class="card flex">
        <h2>Pro Tips</h2>
        <p>New to AnimateForms? No worries! <a href="quickstart">Check out our quickstart guide</a> to get yourself up and running.</p>
      </div>
    </section>
    <br>
    <div class="header">
      <h2>Included Classes</h2>
    </div>
    <section class="flex-smart flex-list">
      <div class="card flex">
        <div class="flex-row justify-between">
          <h2>Animate.cs</h2>
          <a href="#Animate">View Docs</a>
        </div>
        <p>An instantiable class to facilitate with animating WinForms controls.</p>
      </div>
      <div class="card flex">
        <div class="flex-row justify-between">
          <h2>Easings.cs</h2>
          <a href="#Easings">View Docs</a>
        </div>
        <p>Static class with all easing functions from <a href="http://gizma.com/easing/">gizma.com</a>.</p>
      </div>
      <div class="card flex">
        <div class="flex-row justify-between">
          <h2>Helpers.cs</h2>
          <a href="#Helpers">View Docs</a>
        </div>
        <p>Static class with functions to assist with using the API.</p>
      </div>
    </section>
    <br>
    <section class="flex-smart flex-list">
      <div class="card flex">
        <div class="flex-row justify-between">
          <h2>Options.cs</h2>
          <a href="#Options">View Docs</a>
        </div>
        <p>Instantiable options class to assist with using the API.</p>
      </div>
      <div class="card flex">
        <div class="flex-row justify-between">
          <h2>Timeline.cs</h2>
          <a href="#Timeline">View Docs</a>
        </div>
        <p>Instantiable queue of animations. Can be reused.</p>
      </div>
    </section>
  </div>
  <br>
  <div class="container-wide flex-smart">
    <div id="outline" class="flex-column flex-list">
      <h2>Outline</h2>
      <b><a href="#Introduction">Introduction</a></b>
      <b><a href="#Animate">Animate.cs</a></b>
      <a href="#Function">Function</a>
      <a href="#Move">Move</a>
      <a href="#MoveRelative">MoveRelative</a>
      <a href="#Recolor">Recolor</a>
      <a href="#Resize">Resize</a>
      <br>
      <b><a href="#Easings">Easings.cs</a></b>
      <a href="#AllEasings">AllEasings</a>
      <a href="#ImplementedEasings">Implemented</a>
      <br>
      <b><a href="#Helpers">Helpers.cs</a></b>
      <a href="#CollectionToArray">CollectionToArray</a>
      <a href="#HSV">HSV</a>
      <a href="#HSVtoRGB">HSVtoRGB</a>
      <a href="#RGBtoHSV">RGBtoHSV</a>
      <a href="#SortCollectionByName">SortCollectionByName</a>
      <br>
      <b><a href="#Options">Options.cs</a></b>
      <br>
      <b><a href="#Timeline">Timeline.cs</a></b>
      <a href="#Add">Add</a>
      <a href="#Remove">Remove</a>
      <a href="#Execute">Execute</a>
      <br>
    </div>
    <div class="flex flex-column flex-list">
      <div class="header">
        <a name="Introduction"></a>
        <h2>Introduction</h2>
      </div>
      <section>
        <div class="card">
          <p>AnimateForms is built around a single instantiable <a href="#Animate">Animate</a> class to call animations, with each animation (method, e.g. <a href="#Resize">Resize</a>) having a single "simple" form with "advanced" overloads as an option.</p>
          <br>
          <p>A method's "simple" form consists of the parameters <code>Control c, Function easing, int duration</code>, as well as any method-specific parameters needed, like <a href="#Move">Move</a>'s parameter <code>Point moveTo</code>. A method's "advanced" form consists of an <a href="#Options">Options</a> object as a parameter, and any method-specific parameters. The Options object is a flexible tool for calling animations and specifying more parameters, like <code>Delay</code>, and even specifying arrays of Controls or easings to use. See the <a href="#Options">Options</a> documentation for more info.</p>
          <br>
          <p><b>This documentation's included examples assume you have declared an <a href="#Animate">Animate</a> class named <code>a</code>.</b></p>
        </div>
      </section>
      <div class="header">
        <a name="Animate"></a>
        <h2>Animate.cs Members</h2>
      </div>
      <section>
        <div class="card doc">
          <h2>Class Information</h2>
          <h3>Instantiable</h3>
          <p>To start using the animate functions, first declare an animator:</p>
          <p><code>private Animate a = new Animate();</code></p>
          <p>Then, any animated method is run as such:</p>
          <p><code>await a.Method(parameters);</code></p>
          <br>
          <p><b>ProTip #1:</b> By specifying <code>await</code>, the method is run synchronously and will not allow code to continue before the method has finished executing. Instead, a discard can be used to run asynchronously:</p>
          <p><code>_ = a.Method(parameters);</code></p>
          <p><b>ProTip #2:</b> Animate classes will block two animations of the same type on the same control (unless otherwise noted in documentation). This prevents jittery graphics as two animations try to happen at once. As such, only one Animate class should ever be declared in your code.</p>
        </div>
      </section>
      <section>
        <a name="Function"></a>
        <div class="card doc">
          <h2>Function (delegate)</h2>
          <h3>Input: float <code>t, b, c, d</code></h3>
          <h3>Output: int</h3>
          <p>Defines an easing function that takes an input time <b>t</b> (current frame), start value <b>b</b>, change in value <b>c</b>, and duration of animation <b>d</b> and returns an integer defining what the current position should be. In AnimateForms, duration and current time are both always in milliseconds.</p>
          <br>
          <p><b>ProTip #1:</b> You can use this delegate to define your own custom easing function, and plug it into any method for use.</p>
          <p><b>ProTip #2:</b> The <a href="#Easings">Easings</a> class defines many preset static easing functions that can be used as a parameter for methods that need this delegate.</p>
          <br>
          <p><b>Example:</b> <code>Animate.Function f = Easings.Linear;</code></p>
        </div>
      </section>
      <section>
        <a name="Move"></a>
        <div class="card doc">
          <h2>Move</h2>
          <h3>Input: Control <code>control</code>, Function <code>easing</code>, int <code>duration</code>, Point <code>moveTo</code></h3>
          <h3>Output: bool</h3>
          <p>Moves input <code>control</code> to point <code>moveTo</code>, using the specified <code>duration</code>  and <code>easing</code> function. Returns true if animation completed and false if either location is the same or another animation is already in progress.</p>
          <br>
          <p><b>See Also:</b></p>
          <p><a href="#Function">Animate.Function</a></p>
          <p><a href="#Options">Options</a></p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            _ = a.Move(control, Easings.Linear, 1000, new Point(200, 20));</code></p>
            <p><code>
            _ = a.Move(new Options(), new Point(200, 20));
          </code></p>
          <hr>
          <h3>Overloads:</h3>
          <p><b><a href="#Options">Options</a> o, Point moveTo</b></p>
          <p>Applies animation using an Options object. See the Options documentation for possible modifiers.</p>
          <br>
          <p><b><a href="#Options">Options</a> o, Point moveTo, Point offset</b></p>
          <p>Applies animation using an Options object. See the Options documentation for possible modifiers. If multiple controls are specified in the options, an offset will be applied per control (stacking them).</p>
        </div>
      </section>
      <section>
        <a name="MoveRelative"></a>
        <div class="card doc">
          <h2>MoveRelative</h2>
          <h3>Input: Control <code>control</code>, Function <code>easing</code>, int <code>duration</code>, Point <code>offset</code></h3>
          <h3>Output: bool</h3>
          <p>Similar to <a href="#Move">the standard Move animation</a>, however, the offset recursively applies to the current control's location rather than setting it directly. As such, AnimateForms will not block multiple instances of this method at the same time. This creates an effect similar to applying a vector force to a control, except the control will always be offset by the amounts entered.</p>
          <br>
          <p><b>ProTip:</b> Negative values can be entered in a <code>Point</code> object, and will make MoveRelative move the control up or left instead of down or right.</p>
          <br>
          <p><b>See Also:</b></p>
          <p><a href="#Function">Animate.Function</a></p>
          <p><a href="#Options">Options</a></p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            _ = a.MoveRelative(control, Easings.Linear, 1000, new Point(200, -20));</code></p>
            <p><code>
            _ = a.MoveRelative(new Options(), new Point(200, -20));
          </code></p>
          <hr>
          <h3>Overloads:</h3>
          <p><b><a href="#Options">Options</a> o, Point offset</b></p>
          <p>Applies animation using an Options object. See the Options documentation for possible modifiers.</p>
        </div>
      </section>
      <section>
        <a name="Recolor"></a>
        <div class="card doc">
          <h2>Recolor</h2>
          <h3>Input: Control <code>control</code>, Function <code>easing</code>, int <code>duration</code>, Color <code>colorTo</code>, [bool <code>backColor</code> = true]</h3>
          <h3>Output: bool</h3>
          <p>Recolors input <code>control</code> to the specified ARGB color <code>colorTo</code>, using the specified <code>duration</code> and <code>easing</code> function. Returns true if animation completed and false if <code>colorTo</code> is equal to current color, or if another Recolor is running on the same control already. <code>backColor</code> can be used to determine whether the BackColor or the ForeColor property of the control is changed. This function supports using an <a href="#HSV">HSV color object</a> in place of an ARGB color.</p>
          <br>
          <p><b>Note:</b> Limitations currently means transitioning opacities appears flickery and not great.</p>
          <br>
          <p><b>See Also:</b></p>
          <p><a href="../#Function">Animate.Function</a></p>
          <p><a href="../#Options">Options</a></p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            _ = a.Recolor(control, Easings.Linear, 1000, Color.Blue);</code></p>
            <p><code>
            _ = a.Resize(new Options(), Color.Blue, false);
          </code></p>
          <hr>
          <h3>Overloads:</h3>
          <p><b>Input: Control control, Function easing, int duration, <a href="#HSV">Helpers.HSV hsv</a>, [bool backColor = true]</b></p>
          <p>Applies animation using an HSV color object. This is provided by the <a href="#Helpers">Helpers</a> class and results in a different look to the transition.</p>
          <br>
          <p><b><a href="../#Options">Options</a> o, Color color, [bool backColor = true]</b></p>
          <p>Applies animation using an Options object. See the Options documentation for possible modifiers.</p>
          <br>
          <p><b><a href="../#Options">Options</a> o, Color[] colors, [bool backColor = true]</b></p>
          <p>Applies animation using an Options object, cycling through an array of colors for each control. See the Options documentation for possible modifiers.</p>
          <br>
          <p><b><a href="../#Options">Options</a> o, <a href="#HSV">Helpers.HSV color</a>, [bool backColor = true]</b></p>
          <p>Applies animation using an HSV color and an Options object. This is provided by the <a href="#Helpers">Helpers</a> class and results in a different look to the transition.</p>
          <br>
          <p><b><a href="../#Options">Options</a> o, <a href="#HSV">Helpers.HSV colors</a>, [bool backColor = true]</b></p>
          <p>Applies animation using an Options object, cycling through an array of HSV colors for each control. See the Options documentation for possible modifiers.</p>
          <br>
        </div>
      </section>
      <section>
        <a name="Resize"></a>
        <div class="card doc">
          <h2>Resize</h2>
          <h3>Input: Control <code>control</code>, Function <code>easing</code>, int <code>duration</code>, Size <code>sizeTo</code></h3>
          <h3>Output: bool</h3>
          <p>Resizes input <code>control</code> to input <code>sizeTo</code>, using the specified <code>duration</code> and <code>easing</code> function. Returns true if animation completed and false if <code>sizeTo</code> is equal to current size or another Resize is currently being run on the control.</p>
          <br>
          <p><b>See Also:</b></p>
          <p><a href="#Function">Animate.Function</a></p>
          <p><a href="#Options">Options</a></p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            _ = a.Resize(control, Easings.Linear, 1000, new Point(200, 200));</code></p>
            <p><code>
            _ = a.Resize(new Options(), new Size(200, 200));
          </code></p>
          <hr>
          <h3>Overloads:</h3>
          <p><b><a href="#Options">Options</a> o, Size sizeTo</b></p>
          <p>Applies animation using an Options object. See the Options documentation for possible modifiers.</p>
        </div>
      </section>
      <div class="header">
        <a name="Easings"></a>
        <h2>Easings.cs Members</h2>
      </div>
      <section>
        <a name="AllEasings"></a>
        <div class="card doc">
          <h2>AllEasings (static)</h2>
          <h3>Output: Function[]</h3>
          <p>A static Function[] of every easing provided, in case an array of every single easing was needed.</p>
          <br>
          <p><b>See Also:</b> <a href="#Function">Animate.Function</a></p>
          <br>
          <p><b>ProTip:</b> <a href="#Options">Options</a> objects can take multiple easings and multiple input controls, and supported animations will cycle through easings per control.</p>
        </div>
      </section>
      <section>
        <a name="ImplementedEasings"></a>
        <div class="card doc">
          <h2>Implemented Easings (static)</h2>
          <p>All easings found on <a href="http://gizma.com/easing/">Gizma</a> have been implemented as static functions according to the delegate <a href="#Function">Animate.Function</a> and are listed below with their abbreviations that they appear with in the Easings class. Each easing type will have an <code>In</code>, <code>Out</code>, and an <code>InOut</code> variant (except Linear).</p>
          <br>
          <p><b>See Also:</b></p>
          <p><a href="#Function">Animate.Function</a></p>
          <p><a href="https://easings.net">https://easings.net</a> (for visual reference)</p>
          <br>
          <p>Linear - Easings.Linear</p>
          <p>Quadratic - Easings.QuadXX</p>
          <p>Cubic - Easings.CubicXX</p>
          <p>Quartic - Easings.QuartXX</p>
          <p>Quintic - Easings.QuintXX</p>
          <p>Circular - Easings.CircXX</p>
          <p>Exponential - Easings.ExpXX</p>
          <p>Sinusoidal - Easings.SinXX</p>
        </div>
      </section>
      <div class="header">
        <a name="Helpers"></a>
        <h2>Helpers.cs Members</h2>
      </div>
      <section>
        <a name="CollectionToArray"></a>
        <div class="card doc">
          <h2>CollectionToArray (static)</h2>
          <h3>Input: Control.ControlCollection <code>controlCollection</code></h3>
          <h3>Output: Control[]</h3>
          <p>Converts a ControlCollection that results from calling <code>parentControl.Controls</code> to a control array for use in the animation functions.</p>
          <br>
          <p><b>ProTip:</b> ControlCollections seem to be organized randomly, and you should only use this function when the resulting order of the array doesn't matter.</p>
        </div>
      </section>
      <section>
        <a name="HSV"></a>
        <div class="card doc">
          <h2>HSV (struct)</h2>
          <h3>Parameters: double <code>Hue, Saturation, Value</code></h3>
          <p>Holds an HSV color value for use by the <a href="#Recolor">Recolor</a> method or one of the <a href="#RGBtoHSV">RGBtoHSV</a> / <a href="#HSVtoRGB">HSVtoRGB</a> helper functions. Has a constructor so it can be called inline cleanly.</p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            var hsv = new Helpers.HSV(180, 0.5f, 0.5f);</code></p>
            <p><code>
            var hsv = new Helpers.HSV { Hue = 180, Saturation = 1, Value = 1 };
          </code></p>
        </div>
      </section>
      <section>
        <a name="HSVtoRGB"></a>
        <div class="card doc">
          <h2>HSVtoRGB (static)</h2>
          <h3>Input: <a href="#HSV">HSV</a> <code>hsv</code></h3>
          <h3>Output: Color</h3>
          <p>Converts an HSV object into a System.Drawing.Color RGB color.</p>
        </div>
      </section>
      <section>
        <a name="RGBtoHSV"></a>
        <div class="card doc">
          <h2>RGBtoHSV (static)</h2>
          <h3>Input: Color <code>color</code></h3>
          <h3>Output: <a href="#HSV">HSV</a></h3>
          <p>Converts an RGB System.Drawing.Color <code>color</code> into an HSV object. If an alpha is provided, it will be ignored.</p>
        </div>
      </section>
      <section>
        <a name="SortCollectionByName"></a>
        <div class="card doc">
          <h2>SortCollectionByName (static)</h2>
          <h3>Input: Control.ControlCollection <code>controlCollection</code></h3>
          <h3>Output: Control[]</h3>
          <p>Converts a ControlCollection that results from calling <code>parentControl.Controls</code> to a control array, which is sorted by the control's Name property in alphabetical order.</p>
        </div>
      </section>
      <div class="header">
        <a name="Options"></a>
        <h2>Options.cs Members</h2>
      </div>
      <section>
        <a name="Options"></a>
        <div class="card doc">
          <h2>Options</h2>
          <h3>Parameters: Control <code>control</code>, Function <code>easing</code>, int <code>duration</code></h3>
          <h3>Optional Parameters: Control[] <code>controls</code>*, Function[] <code>easings</code>*, int <code>delay</code>, int <code>interval</code></h3>
          <h3>Non-Constructor Paramters: int <code>endDelay</code></h3>
          <p>An options object to allow greater control over some animation functions. It can be created by using a constructor with parameters or by setting each element individually. Currently, all animations will accept an options object and will process all parameters set in one, since the options are universal.</p>
          <br>
          <p><b>See Also:</b> <a href="#Function">Animate.Function</a></p>
          <br>
          <p><b>Easing:</b> Easing function to use. Default = Linear.</p>
          <p><b>Duration:</b> Duration of animation, in milliseconds. Default = 1000ms.</p>
          <p><b>Delay:</b> Delay before animation starts.** Default = 0ms.</p>
          <p><b>EndDelay:</b> Delay after animation ends.** Default = 0ms.</p>
          <p><b>Interval:</b> Time between animations executing in bulk animation commands. Default = 0ms.</p>
          <br>
          <p>*Single control and single functions that get passed in as parameters get parsed into an array by the Options object anyway.</p>
          <p>**If this is specified and the animation returns or will return false, it will still wait for this amount of time.</p>
          <br>
        </div>
      </section>
      <div class="header">
        <a name="Timeline"></a>
        <h2>Timeline.cs Members</h2>
      </div>
      <section>
        <div class="card doc">
          <h2>Class Information</h2>
          <h3>Instantiable</h3>
          <p>Timelines are instantiable objects that can store a list of animations to run later. Instantiate with:</p>
          <p><code>private readonly Timeline t = new Timeline();</code></p>
          <br>
          <p>Then, add animations with the following:</p>
          <p><code>t.Add(() => a.Method(...));</code></p>
          <br>
          <p>Timelines can queue anything that returns a Task&lt;bool&gt;. As such, you can write your own custom functions to run in them.</p>
          <br>
          <p>When you wish to execute the timeline, use the following. Timelines can be reused, and are useful if there is a sequence of animations that need to be called repeatedly.</p>
          <p><code>await t.Execute();</code></p>
          <br>
          <p><b>ProTip #1:</b> Like other animate functions, a discard <code>_ = t.Execute();</code> can be used to run the timeline without blocking code.</p>
        </div>
      </section>
      <section>
        <a name="Add"></a>
        <div class="card doc">
          <h2>Add</h2>
          <h3>Input: Func&lt;Task&lt;bool&gt;&gt; <code>func</code>, [bool shouldAwait = true]</h3>
          <p>Adds an animation to the timeline. Use a lambda to provide the function to add it. The animation added can be removed using the <a href="#Remove">Remove</a> method and the index of the animation added. Should await means the animation should run using an <code>await</code> tag - if this is set false, it will run using a discard <code>_ =</code> instead causing it to happen at the same time as the next animation in queue. This can cause issues as if the animations are of the same type, the second will be rejected.</p>
          <br>
          <p><b>ProTip:</b> You can add your own function to a timeline so long as it returns Task&lt;bool&gt;.</p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            t.Add(() => a.Move(moveOptions, new Point(0, 0)));</code></p>
          <br>
        </div>
      </section>
      <section>
        <a name="Remove"></a>
        <div class="card doc">
          <h2>Remove</h2>
          <h3>Input: int <code>index</code></h3>
          <p>Calls RemoveAt(int index) on the private List of functions within the Timeline object. May throw an ArgumentOutOfBounds exception.</p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            t.Remove(3);</code></p>
            <p><code>
            t.Remove(0, 3);
          </code></p>
          <hr>
          <h3>Overloads:</h3>
          <p><b>int index, int count</b></p>
          <p>Calls RemoveRange on the list instead, with index and count like normal.</p>
          <br>
        </div>
      </section>
      <section>
        <a name="Execute"></a>
        <div class="card doc">
          <h2>Execute</h2>
          <h3>Input: [bool discardAfterRun = false]</h3>
          <p>Runs every action added to the Timeline object. It will await every single call. If discardAfterRun is set to true, after an animation is played, it will be removed from the Timeline object, effectively resetting the Timeline object.</p>
          <br>
          <p><b>Examples:</b> </p>
            <p><code>
            t.Execute();</code></p>
          <br>
        </div>
      </section>
      <br>
    </div>
    <br>
  </div>
  <footer>
    <section class="flex-row">
      <div class="flex">
        <h3>More Stuff</h3>
        <p><a href="https://sdproductions.github.io/p/about">About Us</a></p>
        <p><a href="https://sdproductions.github.io/p/about#privacy">Privacy</a></p>
        <p><a href="https://sdproductions.github.io/p/about#terms">Terms of Use</a></p>
      </div>
      <div class="flex">
        <h3>Contact</h3>
        <p><a href="https://github.com/SDBagel">GitHub</a></p>
        <p><a href="https://sdbagel.com">SDBagel</a></p>
      </div>
    </section>
    <br>
    <p>&#9400; SDBagel 2020</p>
  </footer>
</body>
</html>
